-------------------------------------------------------------------------------
NOTE: THIS FILE CONTAINS SOS DOCUMENTATION. THE FORMAT OF THE FILE IS:

<optional comments>
COMMAND: <cmd name, all lower case>
<descriptive text of the command>
\\ <these are two backslashes, immediately followed by a newline>

<repeat the sequence above>

The first command is "contents" which is the general help screen. The rest 
correspond to SOS command names. This file is embedded as a resource in the SOS 
binary. Be sure to list any new commands here.
-------------------------------------------------------------------------------



COMMAND: contents.
SOS is a debugger extension DLL designed to aid in the debugging of managed
programs. Functions are listed by category, then roughly in order of
importance. Shortcut names for popular functions are listed in parenthesis.
Type "!help <functionname>" for detailed info on that function. 

Object Inspection                  Examining code and stacks
-----------------------------      -----------------------------
DumpObj (do)                       Threads
DumpArray (da)                     CLRStack
DumpStackObjects (dso)             IP2MD
DumpHeap                           U
DumpVC                             DumpStack
GCRoot                             EEStack
ObjSize                            GCInfo
FinalizeQueue                      EHInfo
PrintException (pe)                COMState
TraverseHeap                       BPMD 

Examining CLR data structures      Diagnostic Utilities
-----------------------------      -----------------------------
DumpDomain                         VerifyHeap
EEHeap                             DumpLog
Name2EE                            FindAppDomain
SyncBlk                            SaveModule
DumpMT                             GCHandles
DumpClass                          GCHandleLeaks
DumpMD                             VMMap
Token2EE                           VMStat
EEVersion                          ProcInfo 
DumpModule                         StopOnException (soe)
ThreadPool                         MinidumpMode 
DumpAssembly                       
DumpMethodSig                      Other
DumpRuntimeTypes                   -----------------------------
DumpSig                            FAQ
RCWCleanupList
DumpIL
\\

COMMAND: faq.
>> Where can I get the right version of SOS for my build?

If you are running version 1.1 or 2.0 of the CLR, SOS.DLL is installed in the 
same directory as the main CLR dll (MSCORWKS.DLL). Newer versions of the 
Windows Debugger provide a command to make it easy to load the right copy of 
SOS.DLL:

    ".loadby sos mscorwks"

That will load the SOS extension DLL from the same place that MSCORWKS.DLL is 
loaded in the process. You shouldn't attempt to use a version of SOS.DLL that 
doesn't match the version of MSCORWKS.DLL. You can find the version of 
MSCORWKS.DLL by running 

    "lm v m mscorwks"

in the debugger.

If you are using a dump file created on another machine, it is a little bit
more complex. You need to make sure the mscordacwks.dll file that came with
that install is on your symbol path, and you need to load the corresponding
version of sos.dll (typing .load <full path to sos.dll> rather than using the
.loadby shortcut). Within the Microsoft corpnet, we keep tagged versions 
of mscordacwks.dll, with names like mscordacwks_<architecture>_<version>.dll
that the Windows Debugger can load. If you have the correct symbol path to the
binaries for that version of the Runtime, the Windows Debugger will load the
correct mscordacwks.dll file.

>> I have a chicken and egg problem. I want to use SOS commands, but the CLR
   isn't loaded yet. What can I do?

In the debugger at startup you can type:

    "sxe clrn"

Let the program run, and it will stop with the notice

    "CLR notification: module 'mscorlib' loaded"

At this time you can use SOS commands. To turn off spurious notifications,
type:

    "sxd clrn"    

>> I got the following error message. Now what?

0:000> .loadby sos mscorwks
0:000> !DumpStackObjects
Failed to find runtime DLL (mscorwks.dll), 0x80004005
Extension commands need mscorwks.dll in order to have something to do.
0:000>

This means that the CLR is not loaded yet, or has been unloaded. You need to 
wait until your managed program is running in order to use these commands. If 
you have just started the program a good way to do this is to type 

    bp mscorwks!EEStartup "g @$ra"

in the debugger, and let it run. After the function EEStartup is finished, 
there will be a minimal managed environment for executing SOS commands.

>> I have a partial memory minidump, and !DumpObj doesn't work. Why?

In order to run SOS commands, many CLR data structures need to be traversed. 
When creating a minidump without full memory, special functions are called at
dump creation time to bring those structures into the minidump, and allow a 
minimum set of SOS debugging commands to work. At this time, those commands 
that can provide full or partial output are:

CLRStack
Threads
Help
PrintException
EEVersion

For a minidump created with this minimal set of functionality in mind, you
will get an error message when running any other commands. A full memory dump
(obtained with ".dump /ma <filename>" in the Windows Debugger) is often the 
best way to debug a managed program at this level.

>> What other tools can I use to find my bug?

Turn on Managed Debugging Assistants. These enable additional runtime diagnostics, 
particularly in the area of PInvoke/Interop. Adam Nathan has written some great
information about that:

http://blogs.gotdotnet.com/anathan/categoryview.aspx/Debugging
\\

COMMAND: stoponexception.
!StopOnException [-derived] 
                 [-create | -create2] 
                 <Exception> 
                 [<Pseudo-register number>]

!StopOnException helps when you want the Windows Debugger to stop on a 
particular managed exception, say a System.OutOfMemoryException, but continue
running if other exceptions are thrown. The command can be used in two ways:

1) When you just want to stop on one particular CLR exception

   At the debugger prompt, anytime after loading SOS, type:

   !StopOnException -create System.OutOfMemoryException 1

   The pseudo-register number (1) indicates that SOS can use register $t1 for
   maintaining the breakpoint. The -create parameter allows SOS to go ahead
   and set up the breakpoint as a first-chance exception. -create2 would set
   it up as a 2nd-chance exception. 

2) When you need more complex logic for stopping on a CLR exception

   !StopOnException can be used purely as a predicate in a larger expression.
   If you type:

   !StopOnException System.OutOfMemoryException 3

   then register $t3 will be set to 1 if the last thrown exception on the 
   current thread is a System.OutOfMemoryException. Otherwise, $t3 will be set
   to 0. Using the Windows Debugger scripting language, you could chain 
   such calls together to stop on various exception types. You'll have to 
   manually create such predicates, for example:

   sxe -c "!soe System.OutOfMemoryException 3; 
           !soe -derived System.IOException 4;
           .if(@$t3==1 || @$t4==1) { .echo 'stop' } .else {g}"

The -derived option will cause StopOnException to set the pseudo-register to
1 even if the thrown exception type doesn't exactly match the exception type
given, but merely derives from it. So, "-derived System.Exception" would catch
every exception in the System.Exception heirarchy.

The pseudo-register number is optional. If you don't pass a number, SOS will 
use pseudo-register $t1.

Note that !PrintException with no parameters will print out the last thrown
exception on the current thread (if any). You can use !soe as a shortcut for 
!StopOnException.
\\

COMMAND: minidumpmode.
!MinidumpMode <0 or 1>

Minidumps created with ".dump /m" or ".dump" have a very small set of 
CLR-specific data, just enough to run a subset of SOS commands correctly. You 
are able to run other SOS commands, but they may fail with unexpected errors 
because required areas of memory are not mapped in or only partially mapped 
in. At this time, SOS cannot reliably detect if a dump file is of this type 
(for one thing, custom dump commands can map in additional memory, but there 
is no facility to read meta-information about this memory). You can turn this 
option on to protect against running unsafe commands against small minidumps.

By default, MinidumpMode is 0, so there is no restriction on commands that will
run against a minidump.
\\

COMMAND: dumpobj.
!DumpObj [-nofields] <object address>

This command allows you to examine the fields of an object, as well as learn 
important properties of the object such as the EEClass, the MethodTable, and 
the size.

You might find an object pointer by running !DumpStackObjects and choosing
from the resultant list. Here is a simple object:

0:000> !DumpObj a79d40
Name: Customer
MethodTable: 009038ec
EEClass: 03ee1b84
Size: 20(0x14) bytes
 (C:\pub\unittest.exe)
Fields:
      MT    Field   Offset                 Type  VT     Attr    Value Name
009038ec  4000008        4             Customer   0 instance 00a79ce4 name
009038ec  4000009        8                 Bank   0 instance 00a79d2c bank

Note that fields of type Customer and Bank are themselves objects, and you can 
run !DumpObj on them too. You could look at the field directly in memory using
the offset given. "dd a79d40+8 l1" would allow you to look at the bank field 
directly. Be careful about using this to set memory breakpoints, since objects
can move around in the garbage collected heap.

What else can you do with an object? You might run !GCRoot, to determine what 
roots are keeping it alive. Or you can find all objects of that type with 
"!DumpHeap -type Customer".

The column VT contains the value 1 if the field is a valuetype structure, and
0 if the field contains a pointer to another object. For valuetypes, you can 
take the MethodTable pointer in the MT column, and the Value and pass them to 
the command !DumpVC.

The abbreviation !do can be used for brevity.

The arguments in detail:
-nofields:     do not print fields of the object, useful for objects like 
                  String
\\

COMMAND: dumparray.
!DumpArray 
	[-start <startIndex>]
	[-length <length>]
	[-details]
	[-nofields]
	<array object address>

This command allows you to examine elements of an array object.
The arguments in detail:
 -start <startIndex>: optional, only supported for single dimension array. 
                      Specify from which index the command shows the elements.
 -length <length>:    optional, only supported for single dimension array. 
                      Specify how many elements to show.
 -details:             optional. Ask the command to print out details
                      of the element using !DumpObj and !DumpVC format.
 -nofields:       optional, only takes effect when -detail is used. Do not 
                      print fields of the elements. Useful for array of objects 
                      like String                    

 Example output:

0:000> !dumparray -start 2 -length 5 -details 00ad28d0 
Name: Value[]
MethodTable: 03e41044
EEClass: 03e40fc0
Size: 132(0x84) bytes
Array: Rank 1, Number of elements 10, Type VALUETYPE
Element Type: Value
[2] 00ad28f0
    Name: Value
    MethodTable 03e40f4c
    EEClass: 03ef1698
    Size: 20(0x14) bytes
     (C:\bugs\225271\arraytest.exe)
    Fields:
          MT    Field   Offset                 Type       Attr    Value Name
    5b9a628c  4000001        0         System.Int32   instance        2 x
    5b9a628c  4000002        4         System.Int32   instance        4 y
    5b9a628c  4000003        8         System.Int32   instance        6 z
[3] 00ad28fc
    Name: Value
    MethodTable 03e40f4c
    EEClass: 03ef1698
    Size: 20(0x14) bytes
     (C:\bugs\225271\arraytest.exe)
    Fields:
          MT    Field   Offset                 Type       Attr    Value Name
    5b9a628c  4000001        0         System.Int32   instance        3 x
    5b9a628c  4000002        4         System.Int32   instance        6 y
    5b9a628c  4000003        8         System.Int32   instance        9 z
[4] 00ad2908
    Name: Value
    MethodTable 03e40f4c
    EEClass: 03ef1698
    Size: 20(0x14) bytes
     (C:\bugs\225271\arraytest.exe)
    Fields:
          MT    Field   Offset                 Type       Attr    Value Name
    5b9a628c  4000001        0         System.Int32   instance        4 x
    5b9a628c  4000002        4         System.Int32   instance        8 y
    5b9a628c  4000003        8         System.Int32   instance       12 z
[5] 00ad2914
    Name: Value
    MethodTable 03e40f4c
    EEClass: 03ef1698
    Size: 20(0x14) bytes
     (C:\bugs\225271\arraytest.exe)
    Fields:
          MT    Field   Offset                 Type       Attr    Value Name
    5b9a628c  4000001        0         System.Int32   instance        5 x
    5b9a628c  4000002        4         System.Int32   instance       10 y
    5b9a628c  4000003        8         System.Int32   instance       15 z
[6] 00ad2920
    Name: Value
    MethodTable 03e40f4c
    EEClass: 03ef1698
    Size: 20(0x14) bytes
     (C:\bugs\225271\arraytest.exe)
    Fields:
          MT    Field   Offset                 Type       Attr    Value Name
    5b9a628c  4000001        0         System.Int32   instance        6 x
    5b9a628c  4000002        4         System.Int32   instance       12 y
    5b9a628c  4000003        8         System.Int32   instance       18 z


\\

COMMAND: dumpstackobjects.
!DumpStackObjects [-verify] [top stack [bottom stack]]

This command will display any managed objects it finds within the bounds of 
the current stack. Combined with the stack tracing commands like K and 
!CLRStack, it is a good aid to determining the values of locals and 
parameters.

If you use the -verify option, each non-static CLASS field of an object
candidate is validated. This helps to eliminate false positives. It is not
on by default because very often in a debugging scenario, you are 
interested in objects with invalid fields.

The abbreviation !dso can be used for brevity.
\\

COMMAND: dumpheap.
!DumpHeap [-stat] 
          [-strings] 
          [-short]
          [-min <size>] 
          [-max <size>] 
          [-thinlock] 
          [-startAtLowerBound]
          [-mt <MethodTable address>] 
          [-type <partial type name>] 
          [start [end]]

!DumpHeap is a powerful command that traverses the garbage collected heap, 
collection statistics about objects. With it's various options, it can look for
particular types, restrict to a range, or look for ThinLocks (see !SyncBlk 
documentation). Finally, it will provide a warning if it detects excessive 
fragmentation in the GC heap. 

When called without options, the output is first a list of objects in the heap,
followed by a report listing all the types found, their size and number:

0:000> !dumpheap
 Address       MT     Size
00a71000 0015cde8       12 Free
00a7100c 0015cde8       12 Free
00a71018 0015cde8       12 Free
00a71024 5ba58328       68
00a71068 5ba58380       68
00a710ac 5ba58430       68
00a710f0 5ba5dba4       68
...
total 619 objects
Statistics:
      MT    Count TotalSize Class Name
5ba7607c        1        12 System.Security.Permissions.HostProtectionResource
5ba75d54        1        12 System.Security.Permissions.SecurityPermissionFlag
5ba61f18        1        12 System.Collections.CaseInsensitiveComparer
...
0015cde8        6     10260      Free
5ba57bf8      318     18136 System.String
...

"Free" objects are simply regions of space the garbage collector can use later.
If 30% or more of the heap contains "Free" objects, the process may suffer from
heap fragmentation. This is usually caused by pinning objects for a long time 
combined with a high rate of allocation. Here is example output where !DumpHeap
provides a warning about fragmentation:

<After the Statistics section>
Fragmented blocks larger than 1MB:
    Addr     Size Followed by
00a780c0    1.5MB    00bec800 System.Byte[]
00da4e38    1.2MB    00ed2c00 System.Byte[]
00f16df0    1.2MB    01044338 System.Byte[]

The arguments in detail:

-stat     Restrict the output to the statistical type summary
-strings  Restrict the output to a statistical string value summary
-short    Limits output to just the address of each object. This allows you
          to easily pipe output from the command to another debugger 
          command for automation.
-min      Ignore objects less than the size given in bytes
-max      Ignore objects larger than the size given in bytes
-thinlock Report on any ThinLocks (an efficient locking scheme, see !SyncBlk 
          documentation for more info)
-startAtLowerBound 
          Force heap walk to begin at lower bound of a supplied address range.
          (During plan phase, the heap is often not walkable because objects 
          are being moved. In this case, DumpHeap may report spurious errors, 
          in particular bad objects. It may be possible to traverse more of 
          the heap after the reported bad object. Even if you specify an 
          address range, !DumpHeap will start its walk from the beginning of 
          the heap by default. If it finds a bad object before the specified 
          range, it will stop before displaying the part of the heap in which 
          you are interested. This switch will force !DumpHeap to begin its 
          walk at the specified lower bound. You must supply the address of a 
          good object as the lower bound for this to work. Display memory at 
          the address of the bad object to manually find the next method 
          table (use !dumpmt to verify). If the GC is currently in a call to 
          memcopy, You may also be able to find the next object's address by 
          adding the size to the start address given as parameters.) 
-mt       List only those objects with the MethodTable given
-type     List only those objects whose type name is a substring match of the 
          string provided. 
start     Begin listing from this address
end       Stop listing at this address

A special note about -type: Often, you'd like to find not only Strings, but
System.Object arrays that are constrained to contain Strings. ("new 
String[100]" actually creates a System.Object array, but it can only hold
System.String object pointers). You can use -type in a special way to find
these arrays. Just pass "-type System.String[]" and those Object arrays will
be returned. More generally, "-type <Substring of interesting type>[]".

The start/end parameters can be obtained from the output of !EEHeap -gc. For 
example, if you only want to list objects in the large heap segment:

0:000> !eeheap -gc
Number of GC Heaps: 1
generation 0 starts at 0x00c32754
generation 1 starts at 0x00c32748
generation 2 starts at 0x00a71000
 segment    begin allocated     size
00a70000 00a71000  010443a8 005d33a8(6108072)
Large object heap starts at 0x01a71000
 segment    begin allocated     size
01a70000 01a71000  01a75000 0x00004000(16384)
Total Size  0x5d73a8(6124456)
------------------------------
GC Heap Size  0x5d73a8(6124456)

0:000> !dumpheap 1a71000 1a75000
 Address       MT     Size
01a71000 5ba88bd8     2064
01a71810 0019fe48     2032 Free
01a72000 5ba88bd8     4096
01a73000 0019fe48     4096 Free
01a74000 5ba88bd8     4096
total 5 objects
Statistics:
      MT    Count TotalSize Class Name
0019fe48        2      6128      Free
5ba88bd8        3     10256 System.Object[]
Total 5 objects

Finally, if gc heap corruption is present, you may see an error like this:
0:000> !dumpheap -stat
object 00a73d24: does not have valid MT
curr_object : 00a73d24
Last good object: 00a73d14
----------------

That indicates a serious problem. See the help for !VerifyHeap for more 
information on diagnosing the cause.
\\

COMMAND: dumpvc.
!DumpVC <MethodTable address> <Address>

!DumpVC allows you to examine the fields of a value class. In C#, this is a 
struct, and lives on the stack or within an Object on the GC heap. You need
to know the MethodTable address to tell SOS how to interpret the fields, as
a value class is not a first-class object with it's own MethodTable as the
first field. For example:

0:000> !DumpObj a79d98
Name: Mainy
MethodTable: 009032d8
EEClass: 03ee1424
Size: 28(0x1c) bytes
 (C:\pub\unittest.exe)
Fields:
      MT    Field   Offset                 Type       Attr    Value Name
0090320c  4000010        4            VALUETYPE   instance 00a79d9c m_valuetype
009032d8  400000f        4                CLASS     static 00a79d54 m_sExcep

m_valuetype is a value type. The value in the MT column (0090320c) is the 
MethodTable for it, and the Value column provides the start address:

0:000> !DumpVC 0090320c 00a79d9c
Name: Funny
MethodTable 0090320c
EEClass: 03ee14b8
Size: 28(0x1c) bytes
 (C:\pub\unittest.exe)
Fields:
      MT    Field   Offset                 Type       Attr    Value Name
0090320c  4000001        0                CLASS   instance 00a743d8 signature
0090320c  4000002        8         System.Int32   instance     2345 m1
0090320c  4000003       10       System.Boolean   instance        1 b1
0090320c  4000004        c         System.Int32   instance     1234 m2
0090320c  4000005        4                CLASS   instance 00a79d98 backpointer

!DumpVC is quite a specialized function. Some managed programs make heavy use 
of value classes, while others do not.
\\

COMMAND: gcroot.
!GCRoot [-nostacks] <Object address>

!GCRoot looks for references (or roots) to an object. These can exist in four
places:

   1. On the stack
   2. Within a GC Handle
   3. In an object ready for finalization
   4. As a member of an object found in 1, 2 or 3 above.

First, all stacks will be searched for roots, then handle tables, and finally
the freachable queue of the finalizer. Some caution about the stack roots: 
!GCRoot doesn't attempt to determine if a stack root it encountered is valid 
or is old (discarded) data. You would have to use !CLRStack and !U to 
disassemble the frame that the local or argument value belongs to in order to 
determine if it is still in use.

Because people often want to restrict the search to gc handles and freachable
objects, there is a -nostacks option.
\\

COMMAND: objsize.
!ObjSize [<Object address>]

With no parameters, !ObjSize lists the size of all objects found on managed 
threads. It also enumerates all GCHandles in the process, and totals the size 
of any objects pointed to by those handles. In calculating object size, 
!ObjSize includes the size of all child objects in addition to the parent.

For example, !DumpObj lists a size of 20 bytes for this Customer object:

0:000> !do a79d40
Name: Customer
MethodTable: 009038ec
EEClass: 03ee1b84
Size: 20(0x14) bytes
 (C:\pub\unittest.exe)
Fields:
      MT    Field   Offset                 Type       Attr    Value Name
009038ec  4000008        4                CLASS   instance 00a79ce4 name
009038ec  4000009        8                CLASS   instance 00a79d2c bank
009038ec  400000a        c       System.Boolean   instance        1 valid

but !ObjSize lists 152 bytes:
0:000> !ObjSize a79d40
sizeof(00a79d40) =      152 (    0x98) bytes (Customer)

This is because a Customer points to a Bank, has a name, and the Bank points to
an Address string. You can use !ObjSize to identify any particularly large 
objects, such as a managed cache in a web server.
\\

COMMAND: finalizequeue.
!FinalizeQueue [-detail]

This command lists the objects registered for finalization. Here is output from
a simple program:

0:000> !finalizequeue
SyncBlocks to be cleaned up: 0
MTA Interfaces to be released: 0
STA Interfaces to be released: 1
generation 0 has 4 finalizable objects (0015bc90->0015bca0)
generation 1 has 0 finalizable objects (0015bc90->0015bc90)
generation 2 has 0 finalizable objects (0015bc90->0015bc90)
Ready for finalization 0 objects (0015bca0->0015bca0)
Statistics:
      MT    Count TotalSize Class Name
5ba6cf78        1        24 Microsoft.Win32.SafeHandles.SafeFileHandle
5ba5db04        1        68 System.Threading.Thread
5ba73e28        2       112 System.IO.StreamWriter
Total 4 objects

The GC heap is divided into generations, and objects are listed accordingly. We
see that only generation 0 (the youngest generation) has any objects registered
for finalization. The notation "(0015bc90->0015bca0)" means that if you look at
memory in that range, you'll see the object pointers that are registered:

0:000> dd 15bc90 15bca0-4
0015bc90  00a743f4 00a79f00 00a7b3d8 00a7b47c

You could run !DumpObj on any of those pointers to learn more. In this example,
there are no objects ready for finalization, presumably because they still have
roots (You can use !GCRoot to find out). The statistics section provides a 
higher-level summary of the objects registered for finalization. Note that 
objects ready for finalization are also included in the statistics (if any).

If you pass -detail then you get extra information on any SyncBlocks that need
to be cleaned up, and on any RuntimeCallableWrappers (RCWs) that await cleanup.
Both of these data structures are cached and cleaned up by the finalizer thread
when it gets a chance to run.
\\

COMMAND: printexception.
!PrintException [-nested] [<Exception object address>]

This will format fields of any object derived from System.Exception. One of the
more useful aspects is that it will format the _stackTrace field, which is a 
binary array. If _stackTraceString field is not filled in, that can be helpful 
for debugging. You can of course use !DumpObj on the same exception object to 
explore more fields.

If called with no parameters, PrintException will look for the last outstanding 
exception on the current thread and print it. This will be the same exception
that shows up in a run of !Threads.

!PrintException will notify you if there are any nested exceptions on the 
current managed thread. (A nested exception occurs when you throw another
exception within a catch handler already being called for another exception).
If there are nested exceptions, you can re-run !PrintException with the 
"-nested" option to get full details on the nested exception objects. The
!Threads command will also tell you which threads have nested exceptions.

The abbreviation !pe can be used for brevity.
\\

COMMAND: traverseheap.
!TraverseHeap [-xml] <filename>

!TraverseHeap writes out a file in a format understood by the CLR Profiler. 
You can download the CLR Profiler from this link:

http://www.microsoft.com/downloads/details.aspx?FamilyId=86CE6052-D7F4-4AEB-
9B7A-94635BEEBDDA&displaylang=en

It creates a graphical display of the GC heap to help you analyze the state of
your application. If you pass the "-xml" flag, the file is instead written out
in an easy-to-understand xml format:

    <gcheap>
        <types>
            <type id="1" name="System.String">
            ...
        </types>
        <roots>
            <root kind="handle" address="0x00a73ff0"/>
            <root kind="stack" address="0x0069f0e0"/>
            ...
        </roots>
        <objects>
            <object address="0x00b73030" typeid="1" size="300"/>
            <object address="0x00b75054" typeid="5" size="20">
                <member address="0x00b75088" />
                ...
            </object>
            ...
        </objects>
    </gcheap>

You can break into your process, load SOS, take a snapshot of your heap with 
this function, then continue.
\\

COMMAND: threads.
!Threads [-live] [-special] 

!Threads lists all the mananaged threads in the process. 

-live:     optional. Only print threads associated with a live thread.
-special:  optional. With this switch, the command will display all the special
           threads created by CLR. Those threads might not be managed threads 
           so they might not be shown in the first part of the command's 
           output. Example of special threads include: GC threads (in 
           concurrent GC and server GC), Debugger helper threads, Finalizer 
           threads, AppDomain Unload threads, and Threadpool timer threads.

Each thread has many attributes, many of which can be ignored. The important 
ones are discussed below:

There are three ID columns: 

1) The debugger shorthand ID (In fiber mode, if the thread is a fiber which is
   switched out by the host, this column will be shown as "<<<<") 
2) The CLR Thread ID
3) The OS thread ID.  

If PreEmptiveGC is enabled for a thread, then a garbage collection 
can occur while that thread is running. For example, if you break in while
a managed thread is making a PInvoke call to a Win32 function, that thread 
will be in PreEmptive GC mode. 

The Domain column indicates what AppDomain the thread is currently executing
in. You can pass this value to !DumpDomain to find out more. 

The APT column gives the COM apartment mode. 

Exception will list the last thrown exception (if any) for the thread. More
details can be obtained by passing the pointer value to !PrintException. If
you get the notation "(nested exceptions)", you can get details on those
exceptions by switching to the thread in question, and running 
"!PrintException -nested".
\\

COMMAND: clrstack.
!CLRStack [-a] [-l] [-p]

CLRStack attempts to provide a true stack trace for managed code only. It is
handy for clean, simple traces when debugging straightforward managed 
programs. The -p parameter will show arguments to the managed function. The 
-l parameter can be used to show information on local variables in a frame.
SOS can't retrieve local names at this time, so the output for locals is in
the format <local address> = <value>. The -a (all) parameter is a short-cut
for -l and -p combined.

When you see methods with the name "[Frame:...", that indicates a transition 
between managed and unmanaged code. You could run !IP2MD on the return 
addresses in the call stack to get more information on each managed method.

On IA64 and x64 platforms, Transition Frames are not displayed at this time.
Especially on IA64, there is heavy optimization of parameters and locals. You
can request the JIT compiler to not optimize functions in the managed app by
creating a file myapp.ini (if your program is myapp.exe) in the same directory.
Put the following lines in myapp.ini and re-run:

[.NET Framework Debugging Control]
GenerateTrackingInfo=1
AllowOptimize=0
\\

COMMAND: ip2md.
!IP2MD <Code address>

Given an address in managed JITTED code, IP2MD attempts to find the MethodDesc
associated with it. For example, this output from K:

0:000> K
ChildEBP RetAddr
00a79c78 03ef02ab image00400000!Mainy.Top()+0xb
00a79c78 03ef01a6 image00400000!Mainy.Level(Int32)+0xb
00a79c78 5d3725a1 image00400000!Mainy.Main()+0xee
0012ea04 5d512f59 mscorwks!CallDescrWorkerInternal+0x30
0012ee34 5d7946aa mscorwks!CallDescrWorker+0x109

0:000> !IP2MD 03ef01a6
MethodDesc: 00902f40
Method Name: Mainy.Main()
Class: 03ee1424
MethodTable: 009032d8
mdToken: 0600000d
Module: 001caa38
IsJitted: yes
m_CodeOrIL: 03ef00b8

We have taken a return address into Mainy.Main, and discovered information 
about that method. You could run !U, !DumpMT, !DumpClass, !DumpMD, or 
!DumpModule on the fields listed to learn more.
\\

COMMAND: u.
!U [-gcinfo] [-ehinfo] <MethodDesc address> | <Code address>

Presents an annotated disassembly of a managed method when given a MethodDesc
pointer for the method, or a code address within the method body. Unlike the
debugger "U" function, the entire method from start to finish is printed,
with annotations that convert metadata tokens to names.

<example output>
...
03ef015d b901000000       mov     ecx,0x1
03ef0162 ff156477a25b     call   dword ptr [mscorlib_dll+0x3c7764 (5ba27764)] (System.Console.InitializeStdOutError(Boolean), mdToken: 06000713)
03ef0168 a17c20a701       mov     eax,[01a7207c] (Object: SyncTextWriter)
03ef016d 89442414         mov     [esp+0x14],eax

If you pass the -gcinfo flag, you'll get inline display of the GCInfo for
the method. You can also obtain this information with the !GCInfo command.

If you pass the -ehinfo flag, you'll get inline display of exception info
for the method. (Beginning and end of try/finally/catch handlers, etc.).
You can also obtain this information with the !EHInfo command.
\\

COMMAND: dumpstack.
!DumpStack [-EE] [top stack [bottom stack]]

[x86 documentation]

This command provides a verbose stack trace obtained by "scraping." Therefore
the output is very noisy and potentially confusing. The command is good for
viewing the complete call stack when "kb" gets confused. For best results,
make sure you have valid symbols.

-EE will only show managed functions.

You can also pass a stack range to limit the output. Use the debugger 
extension !teb to get the top and bottom stack values.

[ia64 and x64 documentation]

Rather than scraping, !DumpStack mimics the debugger's "K" command. 
Stackwalking is done very differently on these platforms, so SOS allows the
Windows Debugger to unwind the frames, and supplies managed code information
where possible. The [top stack [bottom stack]] arguments are ignored, but
-EE functions just the same.
\\

COMMAND: eestack.
!EEStack [-short] [-EE]

This command runs !DumpStack on all threads in the process. The -EE option is 
passed directly to !DumpStack. The -short option tries to narrow down the 
output to "interesting" threads only, which is defined by

1) The thread has taken a lock.
2) The thread has been "hijacked" in order to allow a garbage collection.
3) The thread is currently in managed code.

See the documentation for !DumpStack for more info.
\\

COMMAND: ehinfo.
!EHInfo (<MethodDesc address> | <Code address>)

!EHInfo shows the exception handling blocks in a jitted method. For each 
handler, it shows the type, including code addresses and offsets for the clause
block and the handler block. For a TYPED handler, this would be the "try" and
"catch" blocks respectively.

Sample output:

0:000> !ehinfo 33bbd3a
MethodDesc: 03310f68
Method Name: MainClass.Main()
Class: 03571358
MethodTable: 0331121c
mdToken: 0600000b
Module: 001e2fd8
IsJitted: yes
m_CodeOrIL: 033bbca0

EHHandler 0: TYPED
Clause: [033bbd2b, 033bbd3c] [8b, 9c]
Handler: [033bbd3c, 033bbd50] [9c, b0]

EHHandler 1: FINALLY
Clause: [033bbd83, 033bbda3] [e3, 103]
Handler: [033bbda3, 033bbdc5] [103, 125]

EHHandler 2: TYPED
Clause: [033bbd7a, 033bbdc5] [da, 125]
Handler: [033bbdc5, 033bbdd6] [125, 136]

\\

COMMAND: gcinfo.
!GCInfo (<MethodDesc address> | <Code address>)

!GCInfo is especially useful for CLR Devs who are trying to determine if there 
is a bug in the JIT Compiler. It parses the GCEncoding for a method, which is a
compressed stream of data indicating when registers or stack locations contain 
managed objects. It is important to keep track of this information, because if 
a garbage collection occurs, the collector needs to know where roots are so it 
can update them with new object pointer values.

Here is sample output where you can see the change in register state. Normally 
you would print this output out and read it alongside a disassembly of the 
method. For example, the notation "reg EDI becoming live" at offset 0x11 of the
method might correspond to a "mov edi,ecx" statement.

0:000> !gcinfo 5b68dbb8   (5b68dbb8 is the start of a JITTED method)
entry point 5b68dbb8
preJIT generated code
GC info 5b9f2f09
Method info block:
    method      size   = 0036
    prolog      size   =  19
    epilog      size   =   8
    epilog     count   =   1
    epilog      end    = yes
    saved reg.  mask   = 000B
    ebp frame          = yes
    fully interruptible=yes
    double align       = no
    security check     = no
    exception handlers = no
    local alloc        = no
    edit & continue    = no
    varargs            = no
    argument   count   =   4
    stack frame size   =   1
    untracked count    =   5
    var ptr tab count  =   0
    epilog        at   002E
36 D4 8C C7 AA |
93 F3 40 05    |

Pointer table:
14             |             [EBP+14H] an untracked  local
10             |             [EBP+10H] an untracked  local
0C             |             [EBP+0CH] an untracked  local
08             |             [EBP+08H] an untracked  local
44             |             [EBP-04H] an untracked  local
F1 79          | 0011        reg EDI becoming live
72             | 0013        reg ESI becoming live
83             | 0016        push ptr  0
8B             | 0019        push ptr  1
93             | 001C        push ptr  2
9B             | 001F        push ptr  3
56             | 0025        reg EDX becoming live
4A             | 0027        reg ECX becoming live
0E             | 002D        reg ECX becoming dead
10             | 002D        reg EDX becoming dead
E0             | 002D        pop  4 ptrs
F0 31          | 0036        reg ESI becoming dead
38             | 0036        reg EDI becoming dead
FF             |

This function is important for CLR Devs, but very difficult for anyone else to 
make sense of it. You would usually come to use it if you suspect a gc heap 
corruption bug caused by invalid GCEncoding for a particular method.
\\

COMMAND: comstate.
!COMState

!COMState lists the com apartment model for each thread, as well as a Context 
pointer if provided.
\\

COMMAND: bpmd.
!BPMD <module name> <method name>
!BPMD -md <MethodDesc>

!BPMD provides managed breakpoint support. If it can resolve the method name
to a loaded, jitted or ngen'd function it will create a breakpoint with "bp".
If not then either the module that contains the method hasn't been loaded yet
or the module is loaded, but the function is not jitted yet. In these cases,
!bpmd asks the Windows Debugger to receive CLR Notifications, and waits to
receive news of module loads and JITs, at which time it will try to resolve 
the function to a breakpoint.

This brings up a good question: "I want to set a breakpoint on the main
method of my application, but SOS doesn't work until the runtime is loaded.
How can I do this?"

  1) Start the debugger and type: 
       sxe -c "" clrn
  2) g
  3) You'll get the following notification from the debugger:
     "CLR notification: module 'mscorlib' loaded"
  4) Now you can load SOS and use commands. Type
       .loadby sos mscorwks
     then
       !bpmd myapp.exe MyApp.Main
  5) g
  6) You will stop at the start of MyApp.Main. If you type "bl" you will 
     see the breakpoint listed.

!BPMD works equally well with generic types. Adding a breakpoint on a generic 
type sets breakpoints on all already JIT-ted generic methods and sets a pending 
breakpoint for any instantiation that will be JIT-ted in the future.

Example for generics:
	Given the following two classes:

	class G3<T1, T2, T3> 
	{
		...
		public void F(T1 p1, T2 p2, T3 p3)
		{ ... }
	}

	public class G1<T> {
		// static method
		static public void G<W>(W w)
		{ ... }
	}

	One would issue the following commands to set breapoints on G3.F() and 
	G1.G():

	!bpmd myapp.exe G3`3.F
	!bpmd myapp.exe G1`1.G

!BPMD does not accept offsets nor parameters in the method name. If there
are overloaded methods, !bpmd will set a breakpoint for all of them.

In the case of hosted environments such as SQL, the module name may be 
complex, like 'price, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
For this case, just be sure to surround the module name with single quotes,
like:

!bpmd 'price, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null' Price.M2

\\

COMMAND: dumpdomain.
!DumpDomain [<Domain address>]

When called with no parameters, !DumpDomain will list all the AppDomains in the
process. It enumerates each Assembly loaded into those AppDomains as well. 
In addition to your application domain, and any domains it might create, there
are two special domains: the Shared Domain and the System Domain.

Any Assembly pointer in the output can be passed to !DumpAssembly. Any Module 
pointer in the output can be passed to !DumpModule. Any AppDomain pointer can 
be passed to !DumpDomain to limit output only to that AppDomain. Other 
functions provide an AppDomain pointer as well, such as !Threads where it lists
the current AppDomain for each thread.
\\

COMMAND: eeheap.
!EEHeap [-gc] [-loader]

!EEHeap enumerates process memory consumed by internal CLR data structures. You
can limit the output by passing "-gc" or "-loader". All information will be 
displayed otherwise.

The information for the Garbage Collector lists the ranges of each Segment in 
the managed heap. This can be useful if you believe you have an object pointer.
If the pointer falls within a segment range given by "!EEHeap -gc", then you do
have an object pointer, and can attempt to run "!DumpObj" on it.

Here is output for a simple program:

0:000> !eeheap -gc
Number of GC Heaps: 1
generation 0 starts at 0x00a71018
generation 1 starts at 0x00a7100c
generation 2 starts at 0x00a71000
 segment    begin allocated     size
00a70000 00a71000  00a7e01c 0000d01c(53276)
Large object heap starts at 0x01a71000
 segment    begin allocated     size
01a70000 01a71000  01a76000 0x00005000(20480)
Total Size   0x1201c(73756)
------------------------------
GC Heap Size   0x1201c(73756)

So the total size of the GC Heap is only 72K. On a large web server, with 
multiple processors, you can expect to see a GC Heap of 400MB or more. The 
Garbage Collector attempts to collect and reclaim memory only when required to
by memory pressure for better performance. You can also see the notion of 
"generations," wherein the youngest objects live in generation 0, and 
long-lived objects eventually get "promoted" to generation 2.

The loader output lists various private heaps associated with AppDomains. It 
also lists heaps associated with the JIT compiler, and heaps associated with 
Modules. For example:

0:000> !EEHeap -loader
Loader Heap:
--------------------------------------
System Domain: 5e0662a0
LowFrequencyHeap:008f0000(00002000:00001000) Size: 0x00001000 bytes.
HighFrequencyHeap:008f2000(00008000:00001000) Size: 0x00001000 bytes.
StubHeap:008fa000(00002000:00001000) Size: 0x00001000 bytes.
Total size: 0x3000(12288)bytes
--------------------------------------
Shared Domain: 5e066970
LowFrequencyHeap:00920000(00002000:00001000) 03e30000(00010000:00003000) Size: 0x00004000 bytes.
Wasted: 0x00001000 bytes.
HighFrequencyHeap:00922000(00008000:00001000) Size: 0x00001000 bytes.
StubHeap:0092a000(00002000:00001000) Size: 0x00001000 bytes.
Total size: 0x6000(24576)bytes
--------------------------------------
Domain 1: 14f000
LowFrequencyHeap:00900000(00002000:00001000) 03ee0000(00010000:00003000) Size: 0x00004000 bytes.
Wasted: 0x00001000 bytes.
HighFrequencyHeap:00902000(00008000:00003000) Size: 0x00003000 bytes.
StubHeap:0090a000(00002000:00001000) Size: 0x00001000 bytes.
Total size: 0x8000(32768)bytes
--------------------------------------
Jit code heap:
Normal JIT:03ef0000(00010000:00002000) Size: 0x00002000 bytes.
Total size: 0x2000(8192)bytes
--------------------------------------
Module Thunk heaps:
Module 5ba22410: Size: 0x00000000 bytes.
Module 001c1320: Size: 0x00000000 bytes.
Module 001c03f0: Size: 0x00000000 bytes.
Module 001caa38: Size: 0x00000000 bytes.
Total size: 0x0(0)bytes
--------------------------------------
Module Lookup Table heaps:
Module 5ba22410:Size: 0x00000000 bytes.
Module 001c1320:Size: 0x00000000 bytes.
Module 001c03f0:Size: 0x00000000 bytes.
Module 001caa38:03ec0000(00010000:00002000) Size: 0x00002000 bytes.
Total size: 0x2000(8192)bytes
--------------------------------------
Total LoaderHeap size: 0x15000(86016)bytes
=======================================

By using !EEHeap to keep track of the growth of these private heaps, we are 
able to rule out or include them as a source of a memory leak.
\\

COMMAND: name2ee.
!Name2EE <module name> <type or method name>
!Name2EE <module name>!<type or method name>

This function allows you to turn a class name into a MethodTable and EEClass. 
It turns a method name into a MethodDesc. Here is an example for a method:

0:000> !name2ee unittest.exe MainClass.Main
Module: 001caa38
Token: 0x0600000d
MethodDesc: 00902f40
Name: MainClass.Main()
JITTED Code Address: 03ef00b8

and for a class:

0:000> !name2ee unittest!MainClass
Module: 001caa38
Token: 0x02000005
MethodTable: 009032d8
EEClass: 03ee1424
Name: MainClass

The module you are "browsing" with Name2EE needs to be loaded in the process. 
To get a type name exactly right, first browse the module with ILDASM. You
can also pass * as the <module name> to search all loaded managed modules.
<module name> can also be the debugger's name for a module, such as
mscorlib or image00400000.

The Windows Debugger syntax of <module>!<type> is also supported. You can
use an asterisk on the left of the !, but the type on the right side needs
to be fully qualified.

If you are looking for a way to display a static field of a class (and you
don't have an instance of the class, so !dumpobj won't help you), note that
once you have the EEClass, you can run !DumpClass, which will display the
value of all static fields.

There is yet one more way to specify a module name. In the case of modules
loaded from an assembly store (such as a SQL db) rather than disk, the
module name will look like this:

price, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null

For this kind of module, simply use price as the module name:

0:044> !name2ee price Price
Module: 10f028b0 (price, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null)
Token: 0x02000002
MethodTable: 11a47ae0
EEClass: 11a538c8
Name: Price

Where are we getting these module names from? Run !DumpDomain to see a list of
all loaded modules in all domains. And remember that you can browse all the
types in a module with !DumpModule -mt <module pointer>.
\\

COMMAND: syncblk.
!SyncBlk [-all | <syncblk number>]

A SyncBlock is a holder for extra information that doesn't need to be created 
for every object. It can hold COM Interop data, HashCodes, and locking 
information for thread-safe operations.

When called without arguments, !SyncBlk will print the list of SyncBlocks 
corresponding to objects that are owned by a thread. For example, a

    lock(MyObject)
    {
        ....
    }

statement will set MyObject to be owned by the current thread. A SyncBlock will
be created for MyObject, and the thread ownership information stored there 
(this is an oversimplification, see NOTE below). If another thread tries to 
execute the same code, they won't be able to enter the block until the first 
thread exits.

This makes !SyncBlk useful for detecting managed deadlocks. Consider that the
following code is executed by Threads A & B:

    Resource r1 = new Resource();
    Resource r2 = new Resource();

    ...
    
    lock(r1)                             lock(r2)
    {                                    {
        lock(r2)                             lock(r1)
        {                                    {
            ...                                  ...
        }                                    }
    }                                    }

This is a deadlock situation, as Thread A could take r1, and Thread B r2, 
leaving both threads with no option but to wait forever in the second lock 
statement. !SyncBlk will detect this with the following output:

0:003> !syncblk
Index SyncBlock MonitorHeld Recursion Owning Thread Info   SyncBlock Owner
  238 001e40ec            3         1 001e4e60   e04   3   00a7a194 Resource
  239 001e4124            3         1 001e5980   ab8   4   00a7a1a4 Resource

It means that Thread e04 owns object 00a7a194, and Thread ab8 owns object 
00a7a1a4. Combine that information with the call stacks of the deadlock:

(threads 3 and 4 have similar output)  0:003> k
ChildEBP RetAddr
0404ea04 77f5c524 SharedUserData!SystemCallStub+0x4
0404ea08 77e75ee0 ntdll!NtWaitForMultipleObjects+0xc
0404eaa4 5d9de9d6 KERNEL32!WaitForMultipleObjectsEx+0x12c
0404eb38 5d9def80 mscorwks!Thread::DoAppropriateAptStateWait+0x156
0404ecc4 5d9dd8bb mscorwks!Thread::DoAppropriateWaitWorker+0x360
0404ed20 5da628dd mscorwks!Thread::DoAppropriateWait+0xbb
0404ede4 5da4e2e2 mscorwks!CLREvent::Wait+0x29d
0404ee70 5da4dd41 mscorwks!AwareLock::EnterEpilog+0x132
0404ef34 5da4efa3 mscorwks!AwareLock::Enter+0x2c1
0404f09c 5d767880 mscorwks!AwareLock::Contention+0x483
0404f1c4 03f00229 mscorwks!JITutil_MonContention+0x2c0
0404f1f4 5b6ef077 image00400000!Worker.Work()+0x79
...

By looking at the code corresponding to Worker.Work()+0x79 (run "!u 03f00229"),
you can see that thread 3 is attempting to acquire the Resource 00a7a1a4, which
is owned by thread 4.
  
NOTE:
It is not always the case that a SyncBlock will be created for every object 
that is locked by a thread. In version 2.0 of the CLR and above, a mechanism 
called a ThinLock will be used if there is not already a SyncBlock for the 
object in question. ThinLocks will not be reported by the !SyncBlk command. 
You can use "!DumpHeap -thinlock" to list objects locked in this way.
\\

COMMAND: dumpmt.
!DumpMT [-MD] <MethodTable address>

Examine a MethodTable. Each managed object has a MethodTable pointer at the 
start. If you pass the "-MD" flag, you'll also see a list of all the methods 
defined on the object. 
\\

COMMAND: dumpclass.
!DumpClass <EEClass address>

The EEClass is a data structure associated with an object type. !DumpClass 
will show attributes, as well as list the fields of the type. The output is 
similar to !DumpObj. Although static field values will be displayed, 
non-static values won't because you need an instance of an object for that.

You can get an EEClass to look at from !DumpMT, !DumpObj, !Name2EE, and 
!Token2EE among others.
\\

COMMAND: dumpmd.
!DumpMD <MethodDesc address>

This command lists information about a MethodDesc. You can use !IP2MD to turn 
a code address in a managed function into a MethodDesc:

0:000> !dumpmd 902f40
Method Name: Mainy.Main()
Class: 03ee1424
MethodTable: 009032d8
mdToken: 0600000d
Module: 001caa78
IsJitted: yes
m_CodeOrIL: 03ef00b8

If IsJitted is "yes," you can run !U on the m_CodeOrIL pointer to see a 
disassembly of the JITTED code. You can also call !DumpClass, !DumpMT, 
!DumpModule on the Class, MethodTable and Module fields above.
\\

COMMAND: token2ee.
!Token2EE <module name> <token>

This function allows you to turn a metadata token into a MethodTable or 
MethodDesc. Here is an example showing class tokens being resolved:

0:000> !token2ee unittest.exe 02000003
Module: 001caa38
Token: 0x02000003
MethodTable: 0090375c
EEClass: 03ee1ae0
Name: Bank
0:000> !token2ee image00400000 02000004
Module: 001caa38
Token: 0x02000004
MethodTable: 009038ec
EEClass: 03ee1b84
Name: Customer

The module you are "browsing" with Token2EE needs to be loaded in the process. 
This function doesn't see much use, especially since a tool like ILDASM can 
show the mapping between metadata tokens and types/methods in a friendlier way. 
But it could be handy sometimes.

You can pass "*" for <module name> to find what that token maps to in every
loaded managed module. <module name> can also be the debugger's name for a 
module, such as mscorlib or image00400000.
\\

COMMAND: eeversion.
!EEVersion

This prints the Common Language Runtime version. It also tells you if the code 
is running in "Workstation" or "Server" mode, a distinction which affects the 
garbage collector. The most apparent difference in the debugger is that in 
"Server" mode there is one dedicated garbage collector thread per CPU.

A handy supplement to this function is to also run "lm v m mscorwks". That 
will provide more details about the CLR, including where mscorwks.dll is 
loaded from.
\\

COMMAND: dumpmodule.
!DumpModule [-mt] <Module address>

You can get a Module address from !DumpDomain, !DumpAssembly and other 
functions. Here is sample output:

0:000> !dumpmodule 1caa50
Name: C:\pub\unittest.exe
Attributes: PEFile
Assembly: 001ca248
LoaderHeap: 001cab3c
TypeDefToMethodTableMap: 03ec0010
TypeRefToMethodTableMap: 03ec0024
MethodDefToDescMap: 03ec0064
FieldDefToDescMap: 03ec00a4
MemberRefToDescMap: 03ec00e8
FileReferencesMap: 03ec0128
AssemblyReferencesMap: 03ec012c
MetaData start address: 00402230 (1888 bytes)

The Maps listed map metadata tokens to CLR data structures. Without going into 
too much detail, you can examine memory at those addresses to find the 
appropriate structures. For example, the TypeDefToMethodTableMap above can be 
examined:

0:000> dd 3ec0010
03ec0010  00000000 00000000 0090320c 0090375c
03ec0020  009038ec ...

This means TypeDef token 2 maps to a MethodTable with the value 0090320c. You 
can run !DumpMT to verify that. The MethodDefToDescMap takes a MethodDef token 
and maps it to a MethodDesc, which can be passed to !DumpMD.

There is a new option "-mt", which will display the types defined in a module,
and the types referenced by the module. For example:

0:000> !dumpmodule -mt 1aa580
Name: C:\pub\unittest.exe
...<etc>...
MetaData start address: 0040220c (1696 bytes)

Types defined in this module

      MT    TypeDef Name
------------------------------------------------------------------------------
030d115c 0x02000002 Funny
030d1228 0x02000003 Mainy

Types referenced in this module

      MT    TypeRef Name
------------------------------------------------------------------------------
030b6420 0x01000001 System.ValueType
030b5cb0 0x01000002 System.Object
030fceb4 0x01000003 System.Exception
0334e374 0x0100000c System.Console
03167a50 0x0100000e System.Runtime.InteropServices.GCHandle
0336a048 0x0100000f System.GC

\\

COMMAND: threadpool.
!ThreadPool

This command lists basic information about the ThreadPool, including the number
of work requests in the queue, number of completion port threads, and number of
timers.
\\

COMMAND: dumpassembly.
!DumpAssembly <Assembly address>

Example output:

0:000> !dumpassembly 1ca248
Parent Domain: 0014f000
Name: C:\pub\unittest.exe
ClassLoader: 001ca060
  Module Name
001caa50 C:\pub\unittest.exe

An assembly can consist of multiple modules, and those will be listed. You can
get an Assembly address from the output of !DumpDomain.
\\

COMMAND: dumpmethodsig.
!DumpMethodSig <sigaddr> <moduleaddr>

[Not documented yet]
\\

COMMAND: dumpruntimetypes.
!DumpRuntimeTypes 

!DumpRuntimeTypes finds all System.RuntimeType objects in the gc heap and 
prints the type name and MethodTable they refer too. Sample output:

 Address   Domain       MT Type Name
------------------------------------------------------------------------------
  a515f4   14a740 5baf8d28 System.TypedReference
  a51608   14a740 5bb05764 System.Globalization.BaseInfoTable
  a51958   14a740 5bb05b24 System.Globalization.CultureInfo
  a51a44   14a740 5bb06298 System.Globalization.GlobalizationAssembly
  a51de0   14a740 5bb069c8 System.Globalization.TextInfo
  a56b98   14a740 5bb12d28 System.Security.Permissions.HostProtectionResource
  a56bbc   14a740 5baf7248 System.Int32
  a56bd0   14a740 5baf3fdc System.String
  a56cfc   14a740 5baf36a4 System.ValueType
...

\\

COMMAND: dumpsig.
!DumpSig <sigaddr> <moduleaddr>

[Not documented yet]
\\

COMMAND: rcwcleanuplist.
!RCWCleanupList <RCWCleanupList address>

[Not documented yet]
\\

COMMAND: dumpil.
!DumpIL <Managed DynamicMethod object> | 
        <DynamicMethodDesc pointer> |
        <MethodDesc pointer>

!DumpIL prints the IL code associated with a managed method. We added this
function specifically to debug DynamicMethod code which was constructed on
the fly. Happily it works for non-dynamic code as well.

You can use it in three ways: 

  1) If you have a System.Reflection.Emit.DynamicMethod object, just pass
     the pointer as the first argument. 
  2) If you have a DynamicMethodDesc pointer you can use that to print the
     IL associated with the dynamic method.
  3) If you have an ordinary MethodDesc, you can see the IL for that as well,
     just pass it as the first argument.

Note that dynamic IL is constructed a bit differently. Rather than referring
to metadata tokens, the IL points to objects in a managed object array. Here
is a simple example of the output for a dynamic method:

  0:000> !dumpil b741dc
  This is dynamic IL. Exception info is not reported at this time.
  If a token is unresolved, run "!do <addr>" on the addr given
  in parenthesis. You can also look at the token table yourself, by
  running "!DumpArray 00b77388".

  IL_0000: ldstr 70000002 "Inside invoked method "
  IL_0005: call 6000003 System.Console.WriteLine(System.String)
  IL_000a: ldc.i4.1
  IL_000b: newarr 2000004 "System.Int32"
  IL_0010: stloc.0
  IL_0011: ldloc.0
  IL_0012: ret

\\

COMMAND: verifyheap.
!VerifyHeap

!VerifyHeap is a diagnostic tool that checks the garbage collected heap for 
signs of corruption. It walks objects one by one in a pattern like this:

    o = firstobject;
    while(o != endobject)
    {
        o.ValidateAllFields();
        o = (Object *) o + o.Size();
    }

If an error is found, !VerifyHeap will report it. I'll take a perfectly good 
object and corrupt it:

0:000> !DumpObj a79d40
Name: Customer
MethodTable: 009038ec
EEClass: 03ee1b84
Size: 20(0x14) bytes
 (C:\pub\unittest.exe)
Fields:
      MT    Field   Offset                 Type       Attr    Value Name
009038ec  4000008        4                CLASS   instance 00a79ce4 name
009038ec  4000009        8                CLASS   instance 00a79d2c bank
009038ec  400000a        c       System.Boolean   instance        1 valid

0:000> ed a79d40+4 01  (change the name field to the bogus pointer value 1)
0:000> !VerifyHeap
will only produce output if there are errors in the heap:
object 00a79d40: bad member 00000001 at 00a79d44
curr_object : 00a79d40
Last good object: 00a79d2c
----------------

If this gc heap corruption exists, there is a serious bug in your own code or 
in the CLR. In user code, an error in constructing PInvoke calls can cause 
this problem, and running with Managed Debugging Assistants is advised. If that
possibility is eliminated, consider contacting Microsoft Product Support for
help.
\\

COMMAND: dumplog.
!DumpLog [-addr <addressOfStressLog>] [<Filename>]

To aid in diagnosing hard-to-reproduce stress failures, the CLR team added an 
in-memory log capability. The idea was to avoid using locks or I/O which could 
disturb a fragile repro environment. The !DumpLog function allows you to write 
that log out to a file. If no Filename is specified, the file "Stresslog.txt" 
in the current directory is created.

The optional argument addr allows one to specify a stress log other then the 
default one.

0:000> !DumpLog
Attempting to dump Stress log to file 'StressLog.txt'
.................
SUCCESS: Stress log dumped

To turn on the stress log, set the following registry keys under
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework:


(DWORD) StressLog = 1
(DWORD) LogFacility = 0xffffffbf (this is a bit mask, almost all logging is on.
                                  This is also the default value if the key 
                                  isn't specified)
(DWORD) StressLogSize = 65536    (this is the default value if the key isn't
                                  specified)
(DWORD) LogLevel = 6             (this is the default value if the key isn't
                                  specified.  The higher the number the more
                                  detailed logs are generated.  The maximum 
                                  value is decimal 10)

StressLogSize is the size in bytes of the in-memory log allocated for each 
thread in the process. In the case above, each thread gets a 64K log. You 
could increase this to get more logging, but more memory will be required for 
this log in the process. For example, 20 threads with 524288 bytes per thread 
has a memory demand of 10 Megabytes. The stress log is circular so new entries 
will replace older ones on threads which have reached their buffer limit.

The log facilities are defined as follows:
    GC           0x00000001
    GCINFO       0x00000002
    STUBS        0x00000004
    JIT          0x00000008
    LOADER       0x00000010
    METADATA     0x00000020
    SYNC         0x00000040
    EEMEM        0x00000080
    GCALLOC      0x00000100
    CORDB        0x00000200
    CLASSLOADER  0x00000400
    CORPROF      0x00000800
    REMOTING     0x00001000
    DBGALLOC     0x00002000
    EH           0x00004000
    ENC          0x00008000
    ASSERT       0x00010000
    VERIFIER     0x00020000
    THREADPOOL   0x00040000
    GCROOTS      0x00080000
    INTEROP      0x00100000
    MARSHALER    0x00200000
    IJW          0x00400000
    ZAP          0x00800000
    STARTUP      0x01000000
    APPDOMAIN    0x02000000
    CODESHARING  0x04000000
    STORE        0x08000000
    SECURITY     0x10000000
    LOCKS        0x20000000
    BCL          0x40000000

Here is some sample output:

3560   9.981137099 : `SYNC`               RareEnablePremptiveGC: entering. 
Thread state = a030

3560   9.981135033 : `GC`GCALLOC`GCROOTS` ========== ENDGC 4194 (gen = 2, 
collect_classes = 0) ==========={

3560   9.981125826 : `GC`                         Segment mem 00C61000 alloc 
= 00D071F0 used 00D09254 committed 00D17000

3560   9.981125726 : `GC`                     Generation 0 [00CED07C, 00000000
] cur = 00000000

3560   9.981125529 : `GC`                     Generation 1 [00CED070, 00000000
] cur = 00000000

3560   9.981125103 : `GC`                     Generation 2 [00C61000, 00000000
] cur = 00000000

3560   9.981124963 : `GC`                 GC Heap 00000000

3560   9.980618994 : `GC`GCROOTS`         GcScanHandles (Promotion Phase = 0)

The first column is the OS thread ID for the thread appending to the log, 
the second column is the timestamp, the third is the facility category for the 
log entry, and the fourth contains the log message. The facility field is 
expressed as `facility1`facility2`facility3`.  This facilitates the creation of 
filters for displaying only specific message categories.  To make sense of this 
log, you would probably want the Shared Source CLI to find out exactly where 
the log comes from.
\\

COMMAND: findappdomain.
!FindAppDomain <Object address>

!FindAppDomain will attempt to resolve the AppDomain of an object. For example,
using an Object Pointer from the output of !DumpStackObjects:

0:000> !findappdomain 00a79d98
AppDomain: 0014f000
Name: unittest.exe
ID: 1

You can find out more about the AppDomain with the !DumpDomain command. Not 
every object has enough clues about it's origin to determine the AppDomain. 
Objects with Finalizers are the easiest case, as the CLR needs to be able to 
call those when an AppDomain shuts down.
\\

COMMAND: savemodule.
!SaveModule <Base address> <Filename>

This command allows you to take a image loaded in memory and write it to a 
file. This is especially useful if you are debugging a full memory dump, and 
don't have the original DLLs or EXEs. This is most often used to save a managed
binary to a file, so you can disassemble the code and browse types with ILDASM.

The base address of an image can be found with the "LM" debugger command:

0:000> lm
start    end        module name
00400000 00408000   image00400000     (deferred)
10200000 102ac000   MSVCR80D     (deferred)
5a000000 5a0b1000   mscoree      (deferred)
5a140000 5a29e000   mscorjit     (deferred)
5b660000 5c440000   mscorlib_dll     (deferred)
5d1d0000 5e13c000   mscorwks     (deferred)
...

If I wanted to save a copy of mscorwks.dll, I could run:

0:000> !SaveModule 5d1d0000 c:\pub\out.tmp
4 sections in file
section 0 - VA=1000, VASize=e82da9, FileAddr=400, FileSize=e82e00
section 1 - VA=e84000, VASize=24d24, FileAddr=e83200, FileSize=ec00
section 2 - VA=ea9000, VASize=5a8, FileAddr=e91e00, FileSize=600
section 3 - VA=eaa000, VASize=c183c, FileAddr=e92400, FileSize=c1a00

The diagnostic output indicates that the operation was successful. If 
c:\pub\out.tmp already exists, it will be overwritten.
\\

COMMAND: gchandles.
!GCHandles [-perdomain]

!GCHandles provides statistics about GCHandles in the process. Sometimes the 
source of a memory leak is a GCHandle leak. For example, code might keep a 50 
Megabyte array alive because a strong GCHandle points to it, and the handle was
discarded without freeing it.

The most common handles are "Strong Handles," which keep the object they point 
to alive until the handle is explicitly freed. "Pinned Handles" are used to 
prevent the garbage collector from moving an object during collection. These 
should be used sparingly, and for short periods of time. If you don't follow 
that precept, the gc heap can become very fragmented.

Here is sample output from a very simple program:

0:000> !gchandles
GC Handle Statistics:
Strong Handles: 13
Pinned Handles: 3
Async Pinned Handles: 0
Ref Count Handles: 0
Weak Long Handles: 0
Weak Short Handles: 1
Other Handles: 0
Statistics:
      MT    Count TotalSize Class Name
5ba75da8        1        12 System.Security.Permissions.SecurityPermission
5ba5c57c        1        20 System.SharedStatics
5ba76878        2        40 System.Security.PermissionSet
5ba6739c        1        48 System.Reflection.Module
5ba65bb8        2        48 System.Reflection.Assembly
5ba5dba4        1        68 System.Threading.ThreadAbortException
5ba58430        1        68 System.ExecutionEngineException
5ba58380        1        68 System.StackOverflowException
5ba58328        1        68 System.OutOfMemoryException
5ba58c10        1       108 System.AppDomain
5ba5db04        2       136 System.Threading.Thread
5ba88bd8        3     10256 System.Object[]
Total 17 objects

If you run with the -perdomain option, you will get the same output broken 
down by AppDomain.
\\

COMMAND: gchandleleaks.
!GCHandleLeaks

This command is an aid in tracking down GCHandle leaks. It searches all of 
memory for any references to the Strong and Pinned GCHandles in the process, 
and reports what it found. If a handle is found, you'll see the address of the
reference. This might be a stack address or a field within an object, for 
example. If a handle is not found in memory, you'll get notification of that 
too.

The command has diagnostic output which doesn't need to be repeated here. One 
thing to keep in mind is that anytime you search all of memory for a value, you
can get false positives because even though the value was found, it might be 
garbage in that no code knows about the address. You can also get false 
negatives because a user is free to pass that GCHandle to unmanaged code that 
might store the handle in a strange way (shifting bits, for example).

For example, a GCHandle valuetype is stored on the stack with the low bit set 
if it points to a Pinned handle. So !GCHandleLeaks ignores the low bit in it's
searches.

That said, if a serious leak is going on, you'll get a ever-growing set of 
handle addresses that couldn't be found.
\\

COMMAND: vmmap.
!VMMap

!VMMap traverses the virtual address space and lists the type of protection 
applied to each region. Sample output:

0:000> !VMMap
Start    Stop     Length    AllocProtect  Protect       State    Type
00000000-0000ffff 00010000                NA            Free
00010000-00011fff 00002000  RdWr          RdWr          Commit   Private
00012000-0001ffff 0000e000                NA            Free
00020000-00020fff 00001000  RdWr          RdWr          Commit   Private
00021000-0002ffff 0000f000                NA            Free
00030000-00030fff 00001000  RdWr                        Reserve  Private
...
\\

COMMAND: vmstat.
!VMStat

Provides a summary view of the virtual address space, ordered by each type of 
protection applied to that memory (free, reserved, committed, private, mapped, 
image). The TOTAL column is (AVERAGE * BLK COUNT). Sample output below:

0:000> !VMStat
~~~~           ~~~~~~~        ~~~~~~~        ~~~~~~~  ~~~~~~~~~          ~~~~~
TYPE           MINIMUM        MAXIMUM        AVERAGE  BLK COUNT          TOTAL
Free:
Small            4,096         65,536         48,393         27      1,306,611
Medium         139,264        528,384        337,920          4      1,351,680
Large        6,303,744    974,778,368    169,089,706         12  2,029,076,472
Summary          4,096    974,778,368     47,249,646         43  2,031,734,778

Reserve:
Small            4,096         65,536         43,957         41      1,802,237
Medium         249,856      1,019,904        521,557          6      3,129,342
Large        2,461,696     16,703,488     11,956,224          3     35,868,672
Summary          4,096     16,703,488        816,005         50     40,800,250
\\

COMMAND: procinfo.
!ProcInfo [-env] [-time] [-mem]

!ProcInfo lists the environment variables for the process, kernel CPU time, as 
well as memory usage statistics.
\\

